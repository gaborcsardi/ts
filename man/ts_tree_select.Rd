% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ts-tree-select.R
\name{ts_tree_select}
\alias{ts_tree_select}
\title{Select parts of a tree-sitter tree}
\usage{
ts_tree_select(tree, ..., refine = FALSE)
}
\arguments{
\item{tree}{A \code{ts_tree} object as returned by \code{\link[=ts_tree_new]{ts_tree_new()}}.}

\item{...}{Selection expressions, see details.}

\item{refine}{Logical, whether to refine the current selection or start
a new selection.}
}
\value{
A \code{ts_tree} object with the selected parts.
}
\description{
This function is the heart of ts. To edit a tree-sitter tree, you first
need to select the parts you want to delete or update.
\subsection{Installed ts parsers}{

\eval{ts:::format_rd_parser_list(ts:::ts_list_parsers())}
}
}
\details{
A selection starts from the root of the DOM tree, the document node
(see \code{\link[=ts_tree_dom]{ts_tree_dom()}}), unless \code{refine = TRUE} is set, in which case it
starts from the current selection.

A list of selection expressions is applied in order. Each selection
expression selects nodes from the currently selected nodes.

See the various types of selection expressions below.
\subsection{Selectors}{
\subsection{All elements: \code{TRUE}}{

Selects all child nodes of the current nodes.

\eval{ts:::docs("ts_tree_select_true")}
}

\subsection{Specific keys: character vector}{

Selects child nodes with the given names from nodes with named children.
If a node has no named children, it selects nothing from that node.

\eval{ts:::docs("ts_tree_select_character")}
}

\subsection{By position: integer vector}{

Selects child nodes by position. Positive indices count from the start,
negative indices count from the end. Zero indices are not allowed.

\eval{ts:::docs("ts_tree_select_integer")}
}

\subsection{Matching keys: regular expression}{

A character scalar named \code{regex} can be used to select child nodes
whose names match the given regular expression, from nodes with named
children. If a node has no named children, it selects nothing from that
node.

\eval{ts:::docs("ts_tree_select_regex")}
}

\subsection{Tree sitter query matches}{

A character scalar named \code{query} can be used to select nodes matching
a tree-sitter query. See \code{\link[=ts_tree_query]{ts_tree_query()}} for details on tree-sitter
queries.

Instead of a character scalar this can also be a two-element list, where
the first element is the query string and the second element is a
character vector of capture names to select. In this case only nodes
matching the given capture names will be selected.

\eval{ts:::docs("ts_tree_select_tsquery")}
}

\subsection{Explicit node ids}{

You can use \code{I(c(...))} to select nodes by their ids directly. This is
for advanced use cases only.

\eval{ts:::docs("ts_tree_select_ids")}
}

}

\subsection{Refining selections}{

If the \code{refine} argument of \code{\link[=ts_tree_select]{ts_tree_select()}} is \code{TRUE}, then
the selection starts from the already selected elements (all of them
simultanously), instead of starting from the document element.
}

\subsection{The \code{[[} and \verb{[[<-} operators}{

The \code{[[} operator works similarly to \code{\link[=ts_tree_select]{ts_tree_select()}} on ts_tree
objects, but it might be more readable.

The \verb{[[<-} operator works similarly to \code{\link[=ts_tree_select<-]{ts_tree_select<-()}}, but it
might be more readable.

\eval{ts:::docs("ts_tree_select_examples")}
}
}
\examples{
\dontshow{if (requireNamespace("tsjsonc", quietly = TRUE)) withAutoprint(\{ # examplesIf}
json <- ts_tree_new(
  tsjsonc::ts_language_jsonc(),
  text = '{ "a": 1, "b": 2, "c": { "d": 3, "e": 4 } }'
)

json |> ts_tree_select("c", "d")
\dontshow{\}) # examplesIf}
}
